# 75.颜色分类
题目链接：[传送门](https://leetcode-cn.com/problems/sort-colors/)

## 题目描述：
给定一个包含红色、白色和蓝色，一共 n 个元素的数组，**原地**对它们进行排序，使得相同颜色的元素相邻，并按照红色、白色、蓝色顺序排列。此题中，我们使用整数 0、 1 和 2 分别表示红色、白色和蓝色。

**注意**：不能使用代码库中的排序函数来解决这道题。

**示例**：
- 输入: `[2,0,2,1,1,0]`
- 输出: `[0,0,1,1,2,2]`

**进阶**：

- 一个直观的解决方案是使用计数排序的两趟扫描算法。首先，迭代计算出`0`、`1`和`2`元素的个数，然后按照`0`、`1`、`2`的排序，重写当前数组。
- 你能想出一个仅使用常数空间的一趟扫描算法吗？

## 解决方案：
- 时间复杂度：$O(n)$
- 空间复杂度：$O(1)$
- 思路：典型的**荷兰国旗问题**。具体思想就是将`0`放左边，`2`放右边，剩下的位置放的都是`1`。用`p0`表示放置数组左边`0`的最右边界，`p2`表示放置数组右边`2`的最左边界。

## AC代码：
```java
class Solution {
	public void sortColors(int[] nums) {
		int len, p0 = 0, p2, cur = 0;
		if (nums == null || (len = nums.length) < 2) // 0或1个元素直接返回
			return;
		p2 = len - 1;
		while (cur <= p2) { // 注意：cur必须超过p2才可截止 
			if (nums[cur] == 0) { 
                // 若当前元素为0，则交换到p0位置，毫无疑问p0++，cur也要加1，为啥？
				// 在未交换前，分两种情况讨论：①若p0==cur，显然无需交换，并且p0和cur都得加1；
				// ②若p0<cur，则交换过来的p0肯定是1，因为只有当遍历过的元素有1，p0 和cur才不会同步，此时p0必须加1，
				// 而若元素是1只需将cur加1，所以此时可以将cur加1，也可以不加1。
				swap(nums, cur, p0);
				p0++;
				// if (p0 - 1 == cur) cur++; // 可以选择不加1
				cur++; // 选择加1，效果都是一样的
			} else if (nums[cur] == 2) {
				swap(nums, cur, p2); // P2交换过来的数字还没经过确认，所以cur不能加1
				p2--;
			} else // 表示当前元素为1，cur直接加1
				cur++;
		}
	}
	private void swap(int[] nums, int i, int j) {
		if (i == j || (nums[i] ^ nums[j]) == 0) // 注意，若交换的2个元素值相同，则交换后可能出错，此种异或方法必须特判！
			return;
		nums[i] ^= nums[j];
		nums[j] ^= nums[i];
		nums[i] ^= nums[j];
	}
}
```
