# 31.下一个排列
题目链接：[传送门](https://leetcode-cn.com/problems/next-permutation/)

## 题目描述：
实现获取下一个排列的函数，算法需要将给定数字序列重新排列成字典序中下一个更大的排列。

如果不存在下一个更大的排列，则将数字重新排列成最小的排列（即升序排列）。

必须**原地**修改，只允许使用额外常数空间。

以下是一些例子，输入位于左侧列，其相应输出位于右侧列。

`1,2,3` → `1,3,2`

`3,2,1` → `1,2,3`

`1,1,5` → `1,5,1`

## 解决方案：
- 时间复杂度：$O(n)$
- 空间复杂度：$O(1)$
- 思路：思维题。为了得到下一个更大且相邻的全排列，我们尝试用**贪心法**去思考，即从后往前遍历找到第一对相邻且单调递增的元素位置`(i,j)`，则区间`[j, len - 1]`中的元素呈不增性。这时就会想到：直接将这两个相邻的数进行交换，然后不就`ok`了嘛？不，这样得不到下一个相邻且更大的全排列。所以接下来应该从区间`[j, len - 1]` 中逆序遍历找到第一个大于`nums[i]`的元素，并将两者进行交换，这样区间`[j, len - 1]`依旧保持不增性，显然`nums[i]`已保证当前排列比之前排列大，为了得到下一个更大的全排列就应该把区间`[j, len - 1]`反转，这样就刚好求得结果！一个简单的例子：以`1,2,4,6,5`为例子求下一个全排列。

## AC代码：
```java
class Solution {
	public void nextPermutation(int[] nums) {
		int len;
		if (nums == null || (len = nums.length) <= 1)
			return;
		int i = len - 2, j = len - 1, k = len - 1;
        // 先从后往前找到一对相邻的升序元素(i,j)
		while (i >= 0 && nums[i] >= nums[j]) { 
			i--;
			j--;
		}
        // 若不是最后一个排列
		if (i >= 0) { 
            // 从后往前找到第一个大于 nums[i] 的元素：nums[k]
			while (nums[i] >= nums[k]) 
				k--;
            // 将两者进行交换，那么当前序列已满足更大的排列，但可能不满足“下一个”更大的排列
			swap(nums, i, k); 
		}
        // 为了得到下一个更大且相邻的全排列，需将[j, len)升序排，原先是降序排。
		len--;
		while (j < len) { 
			swap(nums, j, len);
			j++;
			len--;
		}
	}
	private void swap(int[] arr, int i, int j) {
        // 注意单个元素或两个相同值则无需交换，否则执行下面时会出错
		if (i == j || arr[i] == arr[j]) 
			return;
		arr[i] ^= arr[j];
		arr[j] ^= arr[i];
		arr[i] ^= arr[j];
	}
}
```