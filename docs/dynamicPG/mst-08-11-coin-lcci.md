# 面试题 08.11.硬币
题目链接：[传送门](https://leetcode-cn.com/problems/coin-lcci/)

## 题目描述：
硬币。给定数量不限的硬币，币值为`25`分、`10`分、`5`分和`1`分，编写代码计算`n`分有几种表示法。(结果可能会很大，你需要将结果模上`1000000007`)

**实例**：
 
- 输入: `n = 5`
- 输出：`2`
- 解释: 有两种方式可以凑成总金额:`5=5`，`5=1+1+1+1+1`。

## 解决方案：
- 时间复杂度：$O(n)$
- 空间复杂度：$O(n)$
- 思路：完全背包计数问题。设`dp[j]`表示用若干个硬币组成钱`j`的方案数，易得状态转移方程为：`dp[j]+=dp[j-i]`（$j>=i$）。意思是当前币值是`i`，那么在组成钱`j`的基础上还可以这样增加新的方案数：用之前的`j-i`分再和当前`i`分组成钱`j`即增加了`dp[j-i] × 1`这么多的方案数。举个栗子：现将`3`分钱兑换成硬币的所有方案数有

```
①1+1+1=3--->1种；
②去掉2枚1分换成1枚2分的硬币1+2=3，那么增加了之前的1种方案数，现共有2种方案数（dp[3]+=dp[3-2]）；
③还有一种就是用1枚3分的硬币替换3枚1分的硬币3+0=3，定义组成0钱的方案数为1种，那么此时也增加1种方案数（dp[3]+=dp[3-3]），所以组成3分钱共有3种方案数。
```
注意：初始化`dp`数组全为`0`，定义`dp[0]=1`，因为组成钱`0`（事实上钱`0`是由钱`i-i=0`即`i=i`这种情况得来的）也算一种方案数，然后对于每种币值，从`i～N`枚举更新累加对应组成钱`j`的方案数即可。

## AC代码：
```java
class Solution {
	public int waysToChange(int n) {
		int[] dp = new int[n + 1];
		int[] coins = new int[] { 1, 5, 10, 25 };
		dp[0] = 1; // 注意初始化为1，即组成钱0的方案数为1
		for (int i = 0; i < coins.length; i++)
			for (int j = coins[i]; j <= n; j++)
				dp[j] = (dp[j] + dp[j - coins[i]]) % 1000000007;
		return dp[n];
	}
}
```