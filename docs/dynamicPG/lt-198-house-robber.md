# 198.打家劫舍
题目链接：[传送门](https://leetcode-cn.com/problems/house-robber/)

## 题目描述：
你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，**如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警**。

给定一个代表每个房屋存放金额的非负整数数组，计算你**不触动警报装置的情况下** ，一夜之内能够偷窃到的最高金额。

**示例**:
- 输入: `[1,2,3,1]`
- 输出: `4`
- 解释: 偷窃 1 号房屋 (金额 = 1) ，然后偷窃 3 号房屋 (金额 = 3)。偷窃到的最高金额 = 1 + 3 = 4 。

## 解决方案：
- 时间复杂度：$O(n)$
- 空间复杂度：$O(n)$
- 思路：动态规划。前提条件：不能偷窃连续的金额！当 $n=1$ 时，偷窃到的最高金额为`nums[0]`；当 $n=2$ 时，偷窃到的最高金额为`max(nums[0],nums[1])`；当 $n \geq 3 $ 时，偷窃到的最高金额为分为两种情况，取当前金额为`dp[i-2]+nums[i]`和不取当前金额：`dp[i-1]`，两者取个max即可。若采用记忆化搜索需要保存一对状态，否则会出错或超时！

## AC代码：
```java
class Solution {
	public int rob(int[] nums) {
		int len;
		if (nums == null || (len = nums.length) == 0)
			return 0;
		int[] dp = new int[len];
		dp[0] = nums[0];
		if (len > 1)
			dp[1] = Math.max(nums[0], nums[1]);
		for (int i = 2; i < len; i++)
			dp[i] = Math.max(nums[i] + dp[i - 2], dp[i - 1]);
		return dp[len - 1];
	}
}
```