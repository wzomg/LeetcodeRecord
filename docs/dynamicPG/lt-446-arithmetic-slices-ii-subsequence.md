# 446.等差数列划分II-子序列
题目链接：[传送门](https://leetcode-cn.com/problems/arithmetic-slices-ii-subsequence/)

## 题目描述：
给你一个整数数组`nums`，返回`nums`中所有**等差子序列**的数目。

如果一个序列中**至少有三个元素**，并且任意两个相邻元素之差相同，则称该序列为等差序列。

例如，`[1, 3, 5, 7, 9]`、`[7, 7, 7, 7]`和`[3, -1, -5, -9]`都是等差序列。再例如，`[1, 1, 2, 5, 7]`不是等差序列。

数组中的子序列是从数组中删除一些元素（也可能不删除）得到的一个序列。例如，`[2,5,10]`是`[1,2,1,2,4,1,5,10]`的一个子序列。

题目数据保证答案是一个32-bit整数。

**提示**：

- $1 \leq$ `nums.length` $ \leq 1000$
- $-2^{31} \leq $ `nums[i]` $ \leq 2^{31} - 1$

**示例**：

- 输入：`nums = [2,4,6,8,10]`
- 输出：7
- 解释：所有的等差子序列为：
```
[2,4,6]
[4,6,8]
[6,8,10]
[2,4,6,8]
[4,6,8,10]
[2,4,6,8,10]
[2,6,10]
```

## 解决方案：
- 时间复杂度：$O(n^2)$
- 空间复杂度：$O(n^2)$
- 思路：计数dp。定义f[i][d]：表示以nums[i]为结尾且公差为d的等差子序列的个数。双重遍历，当前元素nums[i]与前 i - 1 个元素构成的等差子序列对答案的总贡献为 $\sum_{j=0,d=nums[i]-nums[j]}^{i - 1} f[j][d]$，而由贡献累加可得状态转移方程：$ f[i][d] = \sum_{j=0,d=nums[i]-nums[j]}^{i-1} (f[j][d] + 1)$。

## AC代码：
```go
//int：与 uint 一样大小，其取决于操作系统的位数，现在是64位，所以不用考虑数据溢出
func numberOfArithmeticSlices(nums []int) (res int) {
	//map类型的切片：
	f := make([]map[int]int, len(nums)) //第一次分配切片
	for i, x := range nums {
		f[i] = make(map[int]int)     //第二次分配 切片中每个 map 元素
		for j, y := range nums[:i] { //遍历 [0, i)
			d := x - y             //公差 d
			res += f[j][d]         //先累加f[j][d]
			f[i][d] += f[j][d] + 1 //再更新累加到f[i][d]中
		}
	}
	return
}
```