# 639.解码方法II
题目链接：[传送门](https://leetcode-cn.com/problems/decode-ways-ii/)

## 题目描述：
一条包含字母 $ A \sim Z $ 的消息通过以下的方式进行了编码：

```
'A' -> 1
'B' -> 2
...
'Z' -> 26
```

要**解码**一条已编码的消息，所有的数字都必须分组，然后按原来的编码方案反向映射回字母（可能存在多种方式）。例如，"11106" 可以映射为：

- `"AAJF"`对应分组`(1 1 10 6)`
- `"KJF"`对应分组`(11 10 6)`

注意，像`(1 11 06)`这样的分组是无效的，因为`"06"`不可以映射为`'F'`，因为`"6"`与`"06"`不同。

除了上面描述的数字字母映射方案，编码消息中可能包含`'*'`字符，可以表示从`'1'`到`'9'`的任一数字（不包括`'0'`）。例如，编码字符串`"1*"`可以表示`"11"`、`"12"`、`"13"`、`"14"`、`"15"`、`"16"`、`"17"`、`"18"`或`"19"`中的任意一条消息。对`"1*"`进行解码，相当于解码该字符串可以表示的任何编码消息。

给你一个字符串`s`，由数字和`'*'`字符组成，返回**解码**该字符串的方法**数目**。

由于答案数目可能非常大，返回对 $ 10^9 + 7 $ 取余的结果。

**提示**：
- $ 1 \leq $ `s.length` $ \leq 10^5 $
- `s[i]`是 $ 0 \sim 9 $ 中的一位数字或字符`*`


**示例**：
- 输入：`s = "*"`
- 输出：`9`
- 解释：这一条编码消息可以表示 "1"、"2"、"3"、"4"、"5"、"6"、"7"、"8" 或 "9" 中的任意一条。可以分别解码成字符串 "A"、"B"、"C"、"D"、"E"、"F"、"G"、"H" 和 "I" 。因此，"*" 总共有9种解码方法。

## 解决方案：
- 时间复杂度：$O(n)$
- 空间复杂度：$O(n)$
- 思路：计数dp。定义：`dp[i]`表示前i位数字解码的总方案数。考虑第`i-1`位（$ i \in [3, lenS] $，分为两类，注意边界条件：
  - 若`s[i - 1]`为数字：
    - `s[i - 1] != '0'`​，当前位可以独立成一个数字，即：`dp[i] += dp[i-1]`​​。
    - `s[i - 2] == '1'`，当前位（`i-1`）能和第`i-2`位组成一个两位数，即：`dp[i] += dp[i-2]`
    - `s[i - 2] == '2'` 且 `s[i - 1] < '7'`，当前位（`i-1`）才能和第`i-2`位组成两位数，即`dp[i] += dp[i-2]`
    - `s[i - 2] == '*'`：
      - 若`s[i - 1] < '7'`，第`i-1`位可以和第`i−2`位（1或者2）组成两位数，即`dp[i] += dp[i - 2] * 2`
      - 若`s[i - 1] >= '7'`，第`i-1`位可以和第`i-2`位（只能是1）组成两位数，即`dp[i] += dp[i - 2]`
  - 若`s[i - 1]`为`*`：
    - 无论第`i-1`位是什么，第`i-1`位都可以独立成一个数字，即`dp[i] += dp[i - 1] * 9`
    - `s[i - 2] == '1'`，当前（`i-1`）位可以和第`i-2`位组成一个两位数，即`dp[i] += dp[i - 2] * 9`
    - `s[i - 2] == '2'`，当前（`i-1`）位可以和第`i-2`位组成一个两位数，即`dp[i] += dp[i - 2] * 6`
    - `s[i - 2] == '*'`，第`i-2`位既可能是1，也可能是2，即`dp[i] += dp[i - 2] * 15`

## AC代码：
```go
func numDecodings(s string) int {
	lenS, mod := len(s), 1000000007
	dp := make([]int, lenS+1)
	//注意：处理边界情况
	dp[0] = 1
	dp[1] = 1 // 非 '*' 则为1种解码方式
	if s[0] == '*' {
		dp[1] = 9
	}
	if s[0] == '0' {
		dp[0], dp[1] = 0, 0
	}
	for i := 2; i <= lenS; i++ {
		if s[i-1] != '*' {
			if s[i-1] != '0' { //单独解析成一个数字
				dp[i] += dp[i-1]
			}
			if s[i-2] == '1' { //解析成2个数字，都是数字的情况
				dp[i] += dp[i-2]
			} else if s[i-2] == '2' && s[i-1] < '7' {
				dp[i] += dp[i-2]
			} else if s[i-2] == '*' { //星号，数字
				if s[i-1] < '7' {
					dp[i] += dp[i-2] * 2 //可以与 1，2组成2位数
				} else { //只能与1组成2位数
					dp[i] += dp[i-2]
				}
			}
		} else { //当前位是星号
			dp[i] += dp[i-1] * 9
			if s[i-2] == '1' {
				dp[i] += dp[i-2] * 9
			} else if s[i-2] == '2' {
				dp[i] += dp[i-2] * 6
			} else if s[i-2] == '*' {
				dp[i] += dp[i-2] * 15
			}
		}
		dp[i] %= mod
	}
	return dp[lenS]
}
```
